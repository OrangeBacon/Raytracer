//! PBRT File description structs.  Derived from the description at
//! [`https://pbrt.org/fileformat-v3`].  While constructing this description
//! the values of the current transform matrix are calculated and stored in this
//! description, rather than having transform matrix commands stored here.

use std::path::PathBuf;

use geometry::{Bounds2, ConstZero, Number, Point2};

use super::transform_set::TransformSet;

/// Overall description of a pbrt file.  Describes the file at a given float
/// bit width.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct PbrtFile<T: Number> {
    /// The camera to use when viewing the scene.
    pub camera: Camera<T>,

    /// The sampler to generate samples for the image, time, lens and integrator.
    pub sampler: Sampler,

    /// The film specifies the characteristics of the image being generated by the renderer.
    pub film: Film<T>,

    /// The filter used to filter the sample values when computing the final pixel values.
    pub filter: Filter<T>,
}

/// The camera to use when viewing the scene.
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Camera<T: Number> {
    /// Data specific to particular camera implementations.
    pub kind: CameraKind<T>,

    /// The time at which the virtual camera shutter opens.
    pub shutter_open: T,

    /// The time at which the virtual camera shutter closes.
    pub shutter_close: T,

    /// The transforms to use when creating the camera
    pub transform: TransformSet<T>,
}

impl<T: Number> Default for Camera<T> {
    fn default() -> Self {
        Self {
            kind: Default::default(),
            shutter_open: T::ZERO,
            shutter_close: T::ONE,
            transform: Default::default(),
        }
    }
}

/// The type of camera in use
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum CameraKind<T: Number> {
    Environment(CameraEnvironment<T>),
    Orthographic(CameraOrthographic<T>),
    Perspective(CameraPerspective<T>),
    Realistic(CameraRealistic<T>),
}

impl<T: Number> Default for CameraKind<T> {
    fn default() -> Self {
        CameraKind::Perspective(CameraPerspective::default())
    }
}

/// Environment map projection camera.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub struct CameraEnvironment<T: Number> {
    /// The aspect ratio of the film. By default, this is computed from the
    /// x and y resolutions of the film, but it can be overridden if desired.
    pub frame_aspect_ratio: Option<T>,

    /// The bounds of the film plane in screen space. By default, this is [-1,1]
    /// along the shorter image axis and is set proportionally along the longer axis.
    pub screen_window: Option<Bounds2<T>>,
}

/// Orthographic projection camera.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CameraOrthographic<T: Number> {
    /// The aspect ratio of the film. By default, this is computed from the
    /// x and y resolutions of the film, but it can be overridden if desired.
    pub frame_aspect_ratio: Option<T>,

    /// The bounds of the film plane in screen space. By default, this is [-1,1]
    /// along the shorter image axis and is set proportionally along the longer axis.
    pub screen_window: Option<Bounds2<T>>,

    /// The radius of the lens. Used to render scenes with depth of field and
    /// focus effects. The default value yields a pinhole camera.
    pub lens_radius: T,

    /// The focal distance of the lens. If "lens_radius" is zero, this has no effect.
    /// Otherwise, it specifies the distance from the camera origin to the focal plane.
    pub focal_distance: T,
}

impl<T: Number> Default for CameraOrthographic<T> {
    fn default() -> Self {
        Self {
            frame_aspect_ratio: None,
            screen_window: None,
            lens_radius: T::ZERO,
            focal_distance: T::cast(10e30),
        }
    }
}

/// Perspective projection camera.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CameraPerspective<T: Number> {
    /// The aspect ratio of the film. By default, this is computed from the
    /// x and y resolutions of the film, but it can be overridden if desired.
    pub frame_aspect_ratio: Option<T>,

    /// The bounds of the film plane in screen space. By default, this is [-1,1]
    /// along the shorter image axis and is set proportionally along the longer axis.
    pub screen_window: Option<Bounds2<T>>,

    /// The radius of the lens. Used to render scenes with depth of field and
    /// focus effects. The default value yields a pinhole camera.
    pub lens_radius: T,

    /// The focal distance of the lens. If "lens_radius" is zero, this has no effect.
    /// Otherwise, it specifies the distance from the camera origin to the focal plane.
    pub focal_distance: T,

    /// Specifies the field of view for the perspective camera. This is the spread
    /// angle of the viewing frustum along the narrower of the image's width and height.
    pub fov: T,

    /// For convenience to some programs that export from modelling systems, the
    /// camera's field of view can also be specified via the half-angle between the
    /// view direction and the edge of the viewing frustum. If this parameter isn't
    /// provided, then fov is used to set the field of view instead.
    pub half_fov: Option<T>,
}

impl<T: Number> Default for CameraPerspective<T> {
    fn default() -> Self {
        Self {
            frame_aspect_ratio: None,
            screen_window: None,
            lens_radius: T::ZERO,
            focal_distance: T::cast(10e30),
            fov: T::cast(90),
            half_fov: None,
        }
    }
}

/// Realistic camera approximation,  simulates imaging from light rays passing
/// through complex lens systems
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct CameraRealistic<T: Number> {
    /// Specifies the name of a lens description file that gives the collection of
    /// lens elements in the lens system. A number of such lenses are available in
    /// the lenses directory in the pbrt-v3 scenes distribution.
    pub lens_file: Option<PathBuf>,

    /// Diameter of the lens system's aperture, specified in mm. The smaller the
    /// aperture, the less light reaches the film plane, but the greater the range
    /// of distances that are in focus.
    pub aperture_diameter: T,

    /// Distance in meters at which the lens system is focused.
    pub focus_distance: T,

    /// Indicates whether incident radiance at the film plane should just be weighted
    /// by the cosine-to-the-4th term, or whether it should also include the additional
    /// weighting terms that account for the shutter open time and the projected
    /// area of the exit pupil are included so that the image records incident
    /// energy on the film plane.
    pub simple_weighting: bool,
}

impl<T: Number> Default for CameraRealistic<T> {
    fn default() -> Self {
        Self {
            lens_file: None,
            aperture_diameter: T::ONE,
            focus_distance: T::cast(10.0),
            simple_weighting: true,
        }
    }
}

/// The sampler to generate samples for the image, time, lens and integrator.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Sampler {
    Pixel(SamplerPixel),
    Stratified(SamplerStratified),
}

impl Default for Sampler {
    fn default() -> Self {
        Sampler::Pixel(Default::default())
    }
}

/// Data to create a pixel sampler.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SamplerPixel {
    /// The number of samples to take, per pixel. Note that the number of samples
    /// is taken per pixel on average; depending on the actual sampling algorithm
    /// being used, individual pixel areas may have slightly more or slightly fewer.
    pub pixel_samples: u32,

    /// What sort of pixel sampler should be used.
    pub kind: SamplerPixelKind,
}

impl Default for SamplerPixel {
    fn default() -> Self {
        Self {
            pixel_samples: 16,
            kind: Default::default(),
        }
    }
}

/// What sort of pixel sampler should be used.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
pub enum SamplerPixelKind {
    ZeroTwoSequence,
    #[default]
    Halton,
    MaxMinDist,
    Random,
    Sobol,
}

/// Data required to construct a stratified sampler.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct SamplerStratified {
    /// Whether or not the generated samples should be jittered inside each stratum;
    /// this is generally only worth setting to "false" for comparisons between
    /// jittered and uniform samplingâ€”uniform sampling will almost always give a
    /// worse result.
    pub jitter: bool,

    /// The number of samples per pixel to take in the x direction.
    pub x_samples: u32,

    /// The number of samples per pixel to take in the y direction. In general,
    /// "xsamples" and "ysamples" should be set to the same value for best results.
    pub y_samples: u32,
}

impl Default for SamplerStratified {
    fn default() -> Self {
        Self {
            jitter: true,
            x_samples: 2,
            y_samples: 2,
        }
    }
}

/// Data to create an image film (the only kind of film supported)
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct Film<T: Number> {
    /// The number of pixels in the x direction.
    pub x_resolution: u32,

    /// The number of pixels in the y direction.
    pub y_resolution: u32,

    /// The subregion of the image to render. The four values specified should be
    /// fractions in the range [0,1], and they represent x_min, x_max, y_min, and
    /// y_max, respectively. These values are in normalized device coordinates,
    /// with (0,0) in the upper-left corner of the image.
    pub crop_window: Bounds2<T>,

    /// Scale factor to apply to film pixel values before saving the image.
    pub scale: T,

    /// Image sample values with luminance greater than this value are clamped to
    /// have this luminance. (This is a hack, but can be useful for eliminating large
    /// variance spikes in scenes with difficult light transport.)
    pub max_sample_luminance: T,

    /// Diagonal length of the film, in mm. (This value is only used when the
    /// RealisticCamera is used.)
    pub diagonal: T,

    /// The output filename.
    pub file_name: PathBuf,
}

impl<T: Number> Default for Film<T> {
    fn default() -> Self {
        Self {
            x_resolution: 640,
            y_resolution: 480,
            crop_window: Bounds2::new(Point2::ZERO, Point2::new(T::ONE, T::ONE)),
            scale: T::ONE,
            max_sample_luminance: T::INFINITY,
            diagonal: T::cast(35),
            file_name: "pbrt.exr".into(),
        }
    }
}

/// A filter used for filtering the sample values.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Filter<T: Number> {
    Box(FilterBox<T>),
    Gaussian(FilterGaussian<T>),
    Mitchell(FilterMitchell<T>),
    Sinc(FilterSinc<T>),
    Triangle(FilterTriangle<T>),
}

impl<T: Number> Default for Filter<T> {
    fn default() -> Self {
        Filter::Box(Default::default())
    }
}

/// Data used to represent a box filter
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FilterBox<T: Number> {
    /// The width of the filter in the x direction.
    pub x_width: T,

    /// The width of the filter in the y direction.
    pub y_width: T,
}

impl<T: Number> Default for FilterBox<T> {
    fn default() -> Self {
        Self {
            x_width: T::HALF,
            y_width: T::HALF,
        }
    }
}

/// Data used to represent a gaussian filter
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FilterGaussian<T: Number> {
    /// The width of the filter in the x direction.
    pub x_width: T,

    /// The width of the filter in the y direction.
    pub y_width: T,

    /// Alpha controls the falloff rate of the Gaussian filter. Smaller values give
    /// a blurrier image.
    pub alpha: T,
}

impl<T: Number> Default for FilterGaussian<T> {
    fn default() -> Self {
        Self {
            x_width: T::TWO,
            y_width: T::TWO,
            alpha: T::TWO,
        }
    }
}

/// Data used to represent a Mitchell filter
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FilterMitchell<T: Number> {
    /// The width of the filter in the x direction.
    pub x_width: T,

    /// The width of the filter in the y direction.
    pub y_width: T,

    /// Parameters to control the shape of the Mitchell filter. The best results
    /// are generally obtained when B+2C=1.
    pub b: T,

    /// Parameters to control the shape of the Mitchell filter. The best results
    /// are generally obtained when B+2C=1.
    pub c: T,
}

impl<T: Number> Default for FilterMitchell<T> {
    fn default() -> Self {
        Self {
            x_width: T::TWO,
            y_width: T::TWO,
            b: T::cast(1.0 / 3.0),
            c: T::cast(1.0 / 3.0),
        }
    }
}

/// Data used to represent a Lancozos Sinc filter
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FilterSinc<T: Number> {
    /// The width of the filter in the x direction.
    pub x_width: T,

    /// The width of the filter in the y direction.
    pub y_width: T,

    /// Tau controls how many cycles the sinc function passes through before it is
    /// clamped to zero by the windowing function.
    pub tau: T,
}

impl<T: Number> Default for FilterSinc<T> {
    fn default() -> Self {
        Self {
            x_width: T::cast(4),
            y_width: T::cast(4),
            tau: T::cast(3),
        }
    }
}

/// Data used to represent a triangle filter
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct FilterTriangle<T: Number> {
    /// The width of the filter in the x direction.
    pub x_width: T,

    /// The width of the filter in the y direction.
    pub y_width: T,
}

impl<T: Number> Default for FilterTriangle<T> {
    fn default() -> Self {
        Self {
            x_width: T::TWO,
            y_width: T::TWO,
        }
    }
}
